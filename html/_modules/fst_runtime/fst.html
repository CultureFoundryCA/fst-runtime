

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>fst_runtime.fst &mdash; fst_runtime 0.1.9 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=7ab3649f" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=8618f531"></script>
      <script src="../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            fst_runtime
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../source/fst_runtime.html">fst_runtime package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">fst_runtime</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">fst_runtime.fst</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for fst_runtime.fst</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module provides the main class ``Fst`` which defines a finite-state transducer (FST) in-memory as a directed graph.</span>

<span class="sd">Attributes</span>
<span class="sd">----------</span>
<span class="sd">Fst : class</span>
<span class="sd">    Defines an FST in-memory as a directed graph.</span>

<span class="sd">EPSILON : str</span>
<span class="sd">    The epsilon character as encoded in the AT&amp;T ``.att`` FST format; this representation is the string: ``@0@``.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="c1">#region Imports and Constants</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">defaultdict</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">replace</span> <span class="k">as</span> <span class="n">dataclass_replace</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span> <span class="k">as</span> <span class="n">cartesian_product</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Generator</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Iterator</span>

<span class="kn">from</span> <span class="nn">fst_runtime</span> <span class="kn">import</span> <span class="n">logger</span>
<span class="kn">from</span> <span class="nn">fst_runtime.att_format_error</span> <span class="kn">import</span> <span class="n">AttFormatError</span>
<span class="kn">from</span> <span class="nn">fst_runtime.semiring</span> <span class="kn">import</span> <span class="n">Semiring</span>
<span class="kn">from</span> <span class="nn">fst_runtime.tokenize_input</span> <span class="kn">import</span> <span class="n">tokenize_input_string</span>

<span class="n">EPSILON</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;@0@&quot;</span>
<span class="sd">&quot;&quot;&quot;This is the epsilon character as encoded in the AT&amp;T ``.att`` FST format.&quot;&quot;&quot;</span>

<span class="c1">#endregion</span>


<span class="c1">#region Helper Classes</span>

<div class="viewcode-block" id="FstOutput">
<a class="viewcode-back" href="../../source/fst_runtime.html#fst_runtime.fst.FstOutput">[docs]</a>
<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">FstOutput</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A dataclass for holding the output from a given node to another in an FST.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    ouput_string : str</span>
<span class="sd">        This string represents the current state of the FST output; e.g. this could be &quot;r&quot;, then &quot;ru&quot;, then &quot;run&quot; as you walk through the FST.</span>

<span class="sd">    path_weight : Any</span>
<span class="sd">        This is the current weight of the path being walked. This value is computed via the semiring provided to the FST.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">output_string</span><span class="p">:</span> <span class="nb">str</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This string represents the current state of the FST output; e.g. this could be &quot;r&quot;, then &quot;ru&quot;, then &quot;run&quot; as you walk through the FST.&quot;&quot;&quot;</span>

    <span class="n">path_weight</span><span class="p">:</span> <span class="n">Any</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This is the current weight of the path being walked. This value is computed via the semiring provided to the FST.&quot;&quot;&quot;</span>

    <span class="n">input_string</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;uninitialized&#39;</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This is the string that was inputted into the FST that resulted in this output.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="FstOutput.get_serialialization_dictionary">
<a class="viewcode-back" href="../../source/fst_runtime.html#fst_runtime.fst.FstOutput.get_serialialization_dictionary">[docs]</a>
    <span class="k">def</span> <span class="nf">get_serialialization_dictionary</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Gets the dictionary representation of this object for use in i.e. json serialization.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict[str, Any]</span>
<span class="sd">            The dictionary representation of this object.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span></div>


<div class="viewcode-block" id="FstOutput.json_serialize_outputs">
<a class="viewcode-back" href="../../source/fst_runtime.html#fst_runtime.fst.FstOutput.json_serialize_outputs">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">json_serialize_outputs</span><span class="p">(</span><span class="n">outputs</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">FstOutput</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function returns creates the json-serialized string-representation of a collection of FstOutput objects.</span>
<span class="sd">        </span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        outputs : Iterable[FstOutput]</span>
<span class="sd">            The outputs collection to be serialized.</span>
<span class="sd">    </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        str</span>
<span class="sd">            The json-serialized string-representation of the collection of outputs.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">output</span><span class="o">.</span><span class="n">get_serialialization_dictionary</span><span class="p">()</span> <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">values</span><span class="p">)</span></div>
</div>



<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">_AttInputInfo</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents input information from the AT&amp;T file format (``.att``) for a transition to a new state.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    target_state_id : int</span>
<span class="sd">        The ID of the state in the FST that is being transitioned to.</span>

<span class="sd">    transition_output_symbol : str</span>
<span class="sd">        The symbol that is outputted over the transition.</span>

<span class="sd">    transition_weight : Any, optional</span>
<span class="sd">        The weight associated with a transition, should it have one.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">target_state_id</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The ID of the state in the FST that is being transitioned to.&quot;&quot;&quot;</span>

    <span class="n">transition_output_symbol</span><span class="p">:</span> <span class="nb">str</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The symbol that is outputted over the transition.&quot;&quot;&quot;</span>

    <span class="n">transition_weight</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The weight associated with a transition, should it have one.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span> <span class="o">|</span> <span class="nb">str</span> <span class="o">|</span> <span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Defines an iterable for this object to allow for object unpacking.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        int</span>
<span class="sd">            The ID of the state in the FST that is being transitioned to.</span>
<span class="sd">        str</span>
<span class="sd">            The symbol that is outputted over the transition.</span>
<span class="sd">        float</span>
<span class="sd">            The penalty weight of the transition.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">target_state_id</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition_output_symbol</span>
        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">transition_weight</span>


<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">_FstNode</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a directed node in a graph that represents an FST.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    id : int</span>
<span class="sd">        A unique ID given to each node for easier lookup.</span>

<span class="sd">    is_accepting_state : bool</span>
<span class="sd">        Indicates whether the current node is an accepting state of the FST.</span>

<span class="sd">    final_state_weight : Any</span>
<span class="sd">        Represents the weight of acceptance of this state if it is an accepting state.</span>

<span class="sd">    in_transitions : list[_FstEdge]</span>
<span class="sd">        Holds all the edges that lead to this node.</span>

<span class="sd">    out_transitions : list[_FstEdge]</span>
<span class="sd">        Holds all the edges that lead out of this node.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A unique ID is given to each node in order to allow for easier lookup of nodes.&quot;&quot;&quot;</span>

    <span class="n">is_accepting_state</span><span class="p">:</span> <span class="nb">bool</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This boolean holds whether the current node is an accepting state of the FST.</span>
<span class="sd">    When we get to the end of our input string, if we are at an accepting state, that means</span>
<span class="sd">    that the input is valid according to the FST, and so it will then output a value accordingly.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">final_state_weight</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;If this state is an accepting state, then there can be a weight to that acceptance. This value represents that weight.&quot;&quot;&quot;</span>

    <span class="n">in_transitions</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_FstEdge</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This is a node in a directed graph, and this list holds all the edges that lead to this node.&quot;&quot;&quot;</span>

    <span class="n">out_transitions</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">_FstEdge</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This is a node in a directed graph, and this list holds all the edges that lead out of this node.&quot;&quot;&quot;</span>


<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">_FstEdge</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a directed edge in a graph that represents an FST.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    source_node : _FstNode</span>
<span class="sd">        The source node where the edge starts.</span>

<span class="sd">    target_node : _FstNode</span>
<span class="sd">        The target node where the edge ends.</span>

<span class="sd">    input_symbol : str</span>
<span class="sd">        The input symbol consumed by this edge in the FST.</span>

<span class="sd">    output_symbol : str</span>
<span class="sd">        The output symbol produced by this edge in the FST.</span>

<span class="sd">    weight : float, optional</span>
<span class="sd">        The weight that penalizes traversing this edge. Default is 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">source_node</span><span class="p">:</span> <span class="n">_FstNode</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This is an edge in a directed graph, and so it leads from somewhere (source node) to somewhere (target node).&quot;&quot;&quot;</span>

    <span class="n">target_node</span><span class="p">:</span> <span class="n">_FstNode</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This is an edge in a directed graph, and so it leads from somewhere (source node) to somewhere (target node).&quot;&quot;&quot;</span>

    <span class="n">input_symbol</span><span class="p">:</span> <span class="nb">str</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This edge is in an FST, and so it consumes input symbols and outputs output symbols.&quot;&quot;&quot;</span>

    <span class="n">output_symbol</span><span class="p">:</span> <span class="nb">str</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This edge is in an FST, and so it consumes input symbols and outputs output symbols.&quot;&quot;&quot;</span>

    <span class="n">weight</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;This represents a weight on a transition in an FST. The values that this field can take are in the domain of the corresponding semiring.&quot;&quot;&quot;</span>

<span class="c1">#endregion</span>


<div class="viewcode-block" id="Fst">
<a class="viewcode-back" href="../../source/fst_runtime.html#fst_runtime.fst.Fst">[docs]</a>
<span class="k">class</span> <span class="nc">Fst</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a finite-state transducer as a directed graph.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    recursion_limit : int</span>
<span class="sd">        Sets the recursion limit for the generation/analysis functionality, to prevent epsilon cycles from running amok.</span>

<span class="sd">    multichar_symbols : set[str]</span>
<span class="sd">        A copy of the set of multi-character symbols defined in the FST.</span>

<span class="sd">    down_generation : method</span>
<span class="sd">        Generates wordforms from a lemma and sets of prefix and suffix tags.</span>

<span class="sd">    down_generations : method</span>
<span class="sd">        Generates wordforms from many lemmas and common sets of prefix and suffix tags.</span>

<span class="sd">    up_analysis : method</span>
<span class="sd">        Analyzes a wordform and returns any associated tagged lemmas of the wordform.</span>

<span class="sd">    up_analyses : method</span>
<span class="sd">        Analyzes many wordforms and returns their associated tagged lemmas of each wordform in a dictionary keyed to the wordform.</span>
<span class="sd">    &quot;&quot;&quot;</span>


    <span class="c1">#region Variables and Initialization</span>

    <span class="n">_STARTING_STATE</span> <span class="o">=</span> <span class="mi">0</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The starting state in the ``.att`` format is represented by ``0`.</span>
<span class="sd">    This is the &quot;top&quot; of the graph, so when you query down, you start here and go down.</span>
<span class="sd">    Down is like walk+GER -&gt; walking.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_ATT_DEFINES_UNWEIGHTED_ACCEPTING_STATE</span> <span class="o">=</span> <span class="mi">1</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;One input value on a line means that that line represents an accepting state in the ``.att`` file.&quot;&quot;&quot;</span>

    <span class="n">_ATT_DEFINES_WEIGHTED_ACCEPTING_STATE</span> <span class="o">=</span> <span class="mi">2</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Two input values on a line indicates that the line represents an accepting state with a weight in the ``.att`` file.&quot;&quot;&quot;</span>

    <span class="n">_ATT_DEFINES_UNWEIGHTED_TRANSITION</span> <span class="o">=</span> <span class="mi">4</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Four input values on a line mean that the line represents an unweighted transition in the ``.att`` file.&quot;&quot;&quot;</span>

    <span class="n">_ATT_DEFINES_WEIGHTED_TRANSITION</span> <span class="o">=</span> <span class="mi">5</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Five input values on a line mean that the line represents a weighted transition in the ``.att`` file.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">att_file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">semiring</span><span class="p">:</span> <span class="n">Semiring</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">recursion_limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the FST via the provided ``.att`` file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        att_file_path : str</span>
<span class="sd">            The path to the ``.att`` file containing the FST description.</span>

<span class="sd">        semiring: Semiring | None, optional</span>
<span class="sd">            The semiring over which the weights in the FST are defined.</span>

<span class="sd">        recursion_limit : int | None, optional</span>
<span class="sd">            The recursion limit for the generation/analysis functionality. Default is ``None``, which leaves it as the python default of 1000.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">att_file_path</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Failed to provide valid path to input file. Example: ``/path/to/fst.att``.&quot;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="n">att_file_path</span><span class="p">)</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.att&#39;</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Provided file path does not point to a ``.att`` file. Example: ``/path/to/fst.att``.&quot;</span><span class="p">)</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_start_state</span><span class="p">:</span> <span class="n">_FstNode</span> <span class="o">=</span> <span class="n">_FstNode</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="p">[],</span> <span class="p">[])</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This is the entry point into the FST. This is functionally like the root of a tree (even though this is a graph, not a tree).&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_accepting_states</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">_FstNode</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This dictionary holds all the accepting states of the FST.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_multichar_symbols</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This set represents all the multi-character symbols that have been defined in the FST.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_semiring</span><span class="p">:</span> <span class="n">Semiring</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="n">semiring</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This holds the semiring used to perform weight arithmetic on paths in the FST.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_recursion_limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="n">recursion_limit</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;This sets the recursion limit for the generation/analysis functionality, so that epsilon cycles don&#39;t run amok.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_create_graph</span><span class="p">(</span><span class="n">att_file_path</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">multichar_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Public getter for the multichar_symbols variable.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        set[str]</span>
<span class="sd">            A copy of the set of multi-character symbols.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multichar_symbols</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">recursion_limit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Public getter for the recursion_limit variable.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            The recursion limit that has been set. A value less than 1 represents that no recursion limit has been set,</span>
<span class="sd">            and so the current system recursion limit will be used (default for Python applications).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_recursion_limit</span>

    <span class="nd">@recursion_limit</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">recursion_limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_recursion_limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Public setter for the recursion_limit variable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        new_recursion_limit : int</span>
<span class="sd">            The new value to set the recursion limit to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_recursion_limit</span> <span class="o">=</span> <span class="n">new_recursion_limit</span>

    <span class="c1">#endregion</span>


    <span class="c1">#region Graph Creation</span>

    <span class="k">def</span> <span class="nf">_get_or_create_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">_FstNode</span><span class="p">],</span> <span class="n">accepting_states</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">_FstNode</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Tries to get a node from the dictionary, and if it doesn&#39;t exist, creates it first, then returns it.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        state_id : int</span>
<span class="sd">            The unique identifier for the state.</span>

<span class="sd">        nodes : dict[int, _FstNode]</span>
<span class="sd">            The dictionary containing all the nodes, keyed by their state IDs.</span>

<span class="sd">        accepting_states : dict[int, Any]</span>
<span class="sd">            A dictionary whose keys are the IDs of the accepting states, and whose values are the weights of those accepting states.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        _FstNode</span>
<span class="sd">            The node corresponding to the given state ID.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">state_id</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">is_accepting_state</span> <span class="o">=</span> <span class="n">state_id</span> <span class="ow">in</span> <span class="n">accepting_states</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="n">accepting_states</span><span class="p">[</span><span class="n">state_id</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_semiring</span><span class="o">.</span><span class="n">multiplicative_identity</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_semiring</span> <span class="k">else</span> <span class="kc">None</span>

            <span class="n">node</span> <span class="o">=</span> <span class="n">_FstNode</span><span class="p">(</span><span class="n">state_id</span><span class="p">,</span> <span class="n">is_accepting_state</span><span class="p">,</span> <span class="n">final_state_weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span>
            <span class="n">nodes</span><span class="p">[</span><span class="n">state_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>

            <span class="k">if</span> <span class="n">is_accepting_state</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_accepting_states</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_accepting_states</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>

        <span class="k">return</span> <span class="n">node</span>


    <span class="k">def</span> <span class="nf">_read_att_file_into_transitions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">att_file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> \
        <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">_AttInputInfo</span><span class="p">]]],</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span> <span class="c1"># pylint: disable=too-many-branches,too-many-statements</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads in all the transition and state information from the file into the ``transitions`` object,</span>
<span class="sd">        and also saves the accepting states of the FST.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        att_file_path : str</span>
<span class="sd">            The path to the ``.att`` file containing the FST description.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple[dict[int, dict[str, list[_AttInputInfo]]], dict[int, Any]]</span>
<span class="sd">            A tuple containing:</span>
<span class="sd">            - ``transitions`` : dict[int, dict[str, list[_AttInputInfo]]]</span>
<span class="sd">                The dictionary of transitions read from the ``.att`` file, keyed by state ID and input symbol.</span>
<span class="sd">            - ``accepting_states`` : dict[int, Any]</span>
<span class="sd">                A dictionary whose keys are accepting state IDs and whose values are the weight of the accepting state.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            This exception is raised when trying to parse the states and weights into their respective types.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># See comment in ``_create_graph`` for what this object is.</span>
        <span class="n">transitions</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">_AttInputInfo</span><span class="p">]]]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
        <span class="n">accepting_states</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">att_file_path</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">att_file</span><span class="p">:</span>

            <span class="c1"># Parse file into FST graph object.</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">att_file</span><span class="p">:</span>
                
                <span class="c1"># Lines in the AT&amp;T format are tab separated.</span>
                <span class="c1"># No .strip() in case whitespace character is an output. This is very important.</span>
                <span class="n">att_line_items</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">num_defined_items</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">att_line_items</span><span class="p">)</span>

                <span class="c1"># Unweighted accepting state read in only.</span>
                <span class="k">if</span> <span class="n">num_defined_items</span> <span class="o">==</span> <span class="n">Fst</span><span class="o">.</span><span class="n">_ATT_DEFINES_UNWEIGHTED_ACCEPTING_STATE</span><span class="p">:</span>
                    <span class="n">state_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">att_line_items</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">weight</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_semiring</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_semiring</span><span class="o">.</span><span class="n">multiplicative_identity</span>
                    <span class="n">accepting_states</span><span class="p">[</span><span class="n">state_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span>

                <span class="c1"># Unweighted transition.</span>
                <span class="k">elif</span> <span class="n">num_defined_items</span> <span class="o">==</span> <span class="n">Fst</span><span class="o">.</span><span class="n">_ATT_DEFINES_UNWEIGHTED_TRANSITION</span><span class="p">:</span>
                    <span class="n">current_state</span><span class="p">,</span> <span class="n">next_state</span><span class="p">,</span> <span class="n">input_symbol</span><span class="p">,</span> <span class="n">output_symbol</span> <span class="o">=</span> <span class="n">att_line_items</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_symbol</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_multichar_symbols</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">input_symbol</span><span class="p">)</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_symbol</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_multichar_symbols</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">output_symbol</span><span class="p">)</span>

                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">next_state</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">next_state</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="k">raise</span>

                    <span class="n">weight</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_semiring</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_semiring</span><span class="o">.</span><span class="n">multiplicative_identity</span>
                    <span class="n">info</span> <span class="o">=</span> <span class="n">_AttInputInfo</span><span class="p">(</span><span class="n">next_state</span><span class="p">,</span> <span class="n">output_symbol</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>

                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">transitions</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">current_state</span><span class="p">)][</span><span class="n">input_symbol</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="n">transitions</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">current_state</span><span class="p">)][</span><span class="n">input_symbol</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">info</span><span class="p">]</span>

                <span class="c1"># Weighted accepting state.</span>
                <span class="k">elif</span> <span class="n">num_defined_items</span> <span class="o">==</span> <span class="n">Fst</span><span class="o">.</span><span class="n">_ATT_DEFINES_WEIGHTED_ACCEPTING_STATE</span><span class="p">:</span>
                    <span class="n">state_id</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">att_line_items</span>

                    <span class="n">state_id</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">state_id</span><span class="p">)</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_semiring</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_semiring</span><span class="o">.</span><span class="n">convert_string_into_domain</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">weight</span> <span class="o">=</span> <span class="kc">None</span>

                    <span class="n">accepting_states</span><span class="p">[</span><span class="n">state_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span>

                <span class="c1"># Weighted transition.</span>
                <span class="k">elif</span> <span class="n">num_defined_items</span> <span class="o">==</span> <span class="n">Fst</span><span class="o">.</span><span class="n">_ATT_DEFINES_WEIGHTED_TRANSITION</span><span class="p">:</span>
                    <span class="n">current_state</span><span class="p">,</span> <span class="n">next_state</span><span class="p">,</span> <span class="n">input_symbol</span><span class="p">,</span> <span class="n">output_symbol</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">att_line_items</span>

                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_symbol</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_multichar_symbols</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">input_symbol</span><span class="p">)</span>
                    
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_symbol</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_multichar_symbols</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">output_symbol</span><span class="p">)</span>

                    <span class="n">next_state</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">next_state</span><span class="p">)</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_semiring</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_semiring</span><span class="o">.</span><span class="n">convert_string_into_domain</span><span class="p">(</span><span class="n">weight</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">weight</span> <span class="o">=</span> <span class="kc">None</span>

                    <span class="n">info</span> <span class="o">=</span> <span class="n">_AttInputInfo</span><span class="p">(</span><span class="n">next_state</span><span class="p">,</span> <span class="n">output_symbol</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span>

                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">transitions</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">current_state</span><span class="p">)][</span><span class="n">input_symbol</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                        <span class="n">transitions</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">current_state</span><span class="p">)][</span><span class="n">input_symbol</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">info</span><span class="p">]</span>

                <span class="c1"># Invalid input line.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Invalid line in </span><span class="si">%s</span><span class="s2">. Offending line: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">att_file_path</span><span class="p">),</span> <span class="n">line</span><span class="p">)</span>
                    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">transitions</span><span class="p">,</span> <span class="n">accepting_states</span>


    <span class="c1"># This function is easier to read when not split up into more parts. Too many locals disabled for this reason.</span>
    <span class="k">def</span> <span class="nf">_create_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">att_file_path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># pylint: disable=too-many-locals</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the graph that represents the FST from reading in the provided ``.att`` file.</span>

<span class="sd">        This method initializes the FST by reading transitions and accepting states from the</span>
<span class="sd">        specified file, creating all nodes and transitions, and setting the start state.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        att_file_path : str</span>
<span class="sd">            The path to the ``.att`` file containing the FST description.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AttFormatError</span>
<span class="sd">            This error is raised if the FST is ill-defined according to the AT&amp;T format.</span>

<span class="sd">        Note</span>
<span class="sd">        -----</span>
<span class="sd">        ``transitions`` is a dictionary whose key is the source state number as read in from the ``.att`` file</span>
<span class="sd">        (e.g., 22), and whose value is a dictionary. This child dictionary is keyed to the input symbol from </span>
<span class="sd">        the ``.att`` file (e.g., &#39;k&#39; or &#39;+PLURAL&#39;), and whose value is a class that contains the target state </span>
<span class="sd">        number, the output of the transition, and the weight of that transition.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">transitions</span><span class="p">,</span> <span class="n">accepting_states</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_att_file_into_transitions</span><span class="p">(</span><span class="n">att_file_path</span><span class="p">)</span>

        <span class="n">accepting_state_ids</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">accepting_states</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">transition_state_ids</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">transitions</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">all_state_ids</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">accepting_state_ids</span><span class="p">,</span> <span class="n">transition_state_ids</span><span class="p">)</span>

        <span class="n">nodes</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">_FstNode</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># For every state in the FST, create/get that as a _FstNode object</span>
        <span class="k">for</span> <span class="n">current_state</span> <span class="ow">in</span> <span class="n">all_state_ids</span><span class="p">:</span>
            <span class="n">current_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_or_create_node</span><span class="p">(</span><span class="n">current_state</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">accepting_states</span><span class="p">)</span>

            <span class="c1"># Then, for every transition that leads out from this node, get then next node, create the new transition as an _FstEdge object,</span>
            <span class="c1"># and add that transition to the current node&#39;s out transitions and the target node&#39;s in transitions.</span>
            <span class="k">for</span> <span class="n">input_symbol</span><span class="p">,</span> <span class="n">att_inputs</span> <span class="ow">in</span> <span class="n">transitions</span><span class="p">[</span><span class="n">current_state</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">for</span> <span class="n">att_input</span> <span class="ow">in</span> <span class="n">att_inputs</span><span class="p">:</span>

                    <span class="n">next_state</span><span class="p">,</span> <span class="n">output_symbol</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">att_input</span>
                    <span class="n">next_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_or_create_node</span><span class="p">(</span><span class="n">next_state</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">accepting_states</span><span class="p">)</span> <span class="c1"># type: ignore</span>

                    <span class="n">directed_edge</span> <span class="o">=</span> <span class="n">_FstEdge</span><span class="p">(</span><span class="n">current_node</span><span class="p">,</span> <span class="n">next_node</span><span class="p">,</span> <span class="n">input_symbol</span><span class="p">,</span> <span class="n">output_symbol</span><span class="p">,</span> <span class="n">weight</span><span class="p">)</span> <span class="c1"># type: ignore</span>

                    <span class="n">current_node</span><span class="o">.</span><span class="n">out_transitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">directed_edge</span><span class="p">)</span>
                    <span class="n">next_node</span><span class="o">.</span><span class="n">in_transitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">directed_edge</span><span class="p">)</span>

        <span class="c1"># Set the start state.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_start_state</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">[</span><span class="n">Fst</span><span class="o">.</span><span class="n">_STARTING_STATE</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">key_error</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">AttFormatError</span><span class="p">(</span><span class="s2">&quot;There must be a start state specified that has state number ``0` in the input ``.att`` file.&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">key_error</span>

    <span class="c1">#endregion</span>


    <span class="c1"># region Down/Generation Methods</span>

<div class="viewcode-block" id="Fst.down_generations">
<a class="viewcode-back" href="../../source/fst_runtime.html#fst_runtime.fst.Fst.down_generations">[docs]</a>
    <span class="k">def</span> <span class="nf">down_generations</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lemmas</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">prefixes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">suffixes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Generator</span><span class="p">[</span><span class="n">FstOutput</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calls ``down_generation`` for each lemma and returns a dictionary keyed on each lemma.</span>

<span class="sd">        The values in the dictionary are generators of wordforms returned by the FST.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lemmas : list[str]</span>
<span class="sd">            The list of lemmas to process.</span>

<span class="sd">        prefixes : list[list[str]], optional</span>
<span class="sd">            A list of lists containing prefix sequences. Default is None.</span>

<span class="sd">        suffixes : list[list[str]], optional</span>
<span class="sd">            A list of lists containing suffix sequences. Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict[str, Generator[str]]</span>
<span class="sd">            A dictionary where each key is a lemma and the value is a generator of wordforms generated by the FST.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        down_generation : For more information on how each lemma is processed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">prefixes</span> <span class="o">=</span> <span class="p">[[</span><span class="n">EPSILON</span><span class="p">]]</span> <span class="k">if</span> <span class="n">prefixes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">prefixes</span>
        <span class="n">suffixes</span> <span class="o">=</span> <span class="p">[[</span><span class="n">EPSILON</span><span class="p">]]</span> <span class="k">if</span> <span class="n">suffixes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">suffixes</span>

        <span class="n">generated_forms</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">lemma</span> <span class="ow">in</span> <span class="n">lemmas</span><span class="p">:</span>
            <span class="n">generated_forms</span><span class="p">[</span><span class="n">lemma</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">down_generation</span><span class="p">(</span><span class="n">lemma</span><span class="p">,</span> <span class="n">prefixes</span><span class="o">=</span><span class="n">prefixes</span><span class="p">,</span> <span class="n">suffixes</span><span class="o">=</span><span class="n">suffixes</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">generated_forms</span></div>



<div class="viewcode-block" id="Fst.down_generation">
<a class="viewcode-back" href="../../source/fst_runtime.html#fst_runtime.fst.Fst.down_generation">[docs]</a>
    <span class="k">def</span> <span class="nf">down_generation</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lemma</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">prefixes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">suffixes</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">FstOutput</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries the FST in the down/generation direction.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lemma : str</span>
<span class="sd">            The lemma to process.</span>

<span class="sd">        prefixes : list[list[str]], optional</span>
<span class="sd">            A list of lists containing prefix sequences. Default is None.</span>

<span class="sd">        suffixes : list[list[str]], optional</span>
<span class="sd">            A list of lists containing suffix sequences. Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Generator[FstOutput]</span>
<span class="sd">            A generator of generated forms that are accepted by the FST along with their weights.</span>

<span class="sd">        Note</span>
<span class="sd">        -----</span>
<span class="sd">        When provided lists of prefixes and suffixes as well as the lemma, it fully permutes the tags based on the slots of the affixes. </span>
<span class="sd">        For example, the lemma &quot;wal&quot; in English (for the lemma &quot;walk&quot;), with prefix tags ``[[&quot;+VERB&quot;], [&quot;+INF&quot;, &quot;+PAST&quot;, &quot;+GER&quot;, &quot;+PRES&quot;]]``. </span>
<span class="sd">        Then, these would be fully permuted to &quot;wal+VERB+INF&quot;, &quot;wal+VERB+PAST&quot;, &quot;wal+VERB+GER&quot;, and &quot;wal+VERB+PRES&quot;; likewise with any prefixes. </span>
<span class="sd">        All of these constructions are then walked over the FST to see if we end at an accepting state. If so, the generated forms </span>
<span class="sd">        (i.e., walk, walked, walking, walks) will be added to a list and returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">prefixes</span> <span class="o">=</span> <span class="p">[[</span><span class="n">EPSILON</span><span class="p">]]</span> <span class="k">if</span> <span class="n">prefixes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">prefixes</span>
        <span class="n">suffixes</span> <span class="o">=</span> <span class="p">[[</span><span class="n">EPSILON</span><span class="p">]]</span> <span class="k">if</span> <span class="n">suffixes</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">suffixes</span>

        <span class="n">permutations</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="n">prefixes</span> <span class="o">+</span> <span class="p">[[</span><span class="n">lemma</span><span class="p">]]</span> <span class="o">+</span> <span class="n">suffixes</span>

        <span class="n">queries</span><span class="p">:</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">Fst</span><span class="o">.</span><span class="n">_permute_tags</span><span class="p">(</span><span class="n">permutations</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Queries created: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">queries</span><span class="p">)</span>

        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traverse_down</span><span class="p">(</span><span class="n">queries</span><span class="p">)</span></div>



    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_permute_tags</span><span class="p">(</span><span class="n">parts</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">separator</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recursively descends into the tags to create all permutations of the given tags in the given order.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parts : list[list[str]]</span>
<span class="sd">            A list of lists containing tag sequences to permute.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        list[str]</span>
<span class="sd">            A list of all permutations of the given tags in the given order.</span>

<span class="sd">        Note</span>
<span class="sd">        -----</span>
<span class="sd">        This method generates all possible permutations of the tags by recursively descending through the provided lists of tags.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">separator_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">separator</span><span class="p">)</span>
        <span class="n">resulting_products</span> <span class="o">=</span> <span class="n">cartesian_product</span><span class="p">(</span><span class="o">*</span><span class="n">parts</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">product</span> <span class="ow">in</span> <span class="n">resulting_products</span><span class="p">:</span>
            <span class="n">combined_parts</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

            <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">product</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tag</span> <span class="o">==</span> <span class="n">EPSILON</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">combined_parts</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">tag</span><span class="si">}{</span><span class="n">separator</span><span class="si">}</span><span class="s1">&#39;</span>
            
            <span class="c1"># Chops off the extra plus sign at the end.</span>
            <span class="k">yield</span> <span class="n">combined_parts</span><span class="p">[:</span><span class="o">-</span><span class="n">separator_length</span><span class="p">]</span>

    
    <span class="k">def</span> <span class="nf">_traverse_down</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">queries</span><span class="p">:</span> <span class="n">Generator</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">FstOutput</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handles all the queries down the FST and returns all the resulting outputs that were found.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        queries : list[str]</span>
<span class="sd">            The list of queries to process down the FST.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Generator[FstOutput]</span>
<span class="sd">            A generator of all the resulting outputs that were found with their corresponding weights.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">original_recursion_limit</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="c1"># If the recursion limit has been set, the save the original value, and set it to the specified one.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">recursion_limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">original_recursion_limit</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">getrecursionlimit</span><span class="p">()</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">setrecursionlimit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">recursion_limit</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">query</span> <span class="ow">in</span> <span class="n">queries</span><span class="p">:</span>
            <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__traverse_down</span><span class="p">(</span>
                <span class="n">current_node</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_start_state</span><span class="p">,</span>
                <span class="n">input_tokens</span><span class="o">=</span><span class="n">tokenize_input_string</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_multichar_symbols</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
                <span class="n">finalized_output_string</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">output_string</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">EPSILON</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">dataclass_replace</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">output_string</span><span class="o">=</span><span class="n">finalized_output_string</span><span class="p">,</span> <span class="n">input_string</span><span class="o">=</span><span class="n">query</span><span class="p">)</span>

        <span class="c1"># Reset recursion limit before exiting the function.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">recursion_limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">setrecursionlimit</span><span class="p">(</span><span class="n">original_recursion_limit</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__traverse_down</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_node</span><span class="p">:</span> <span class="n">_FstNode</span><span class="p">,</span> <span class="n">input_tokens</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">FstOutput</span><span class="p">]:</span> <span class="c1"># pylint: disable=too-many-branches</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Traverses down the FST beginning at an initial provided node.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        current_node : _FstNode</span>
<span class="sd">            The current node in the recursion. Provide the FST&#39;s start state if calling this for the first time.</span>

<span class="sd">        input_tokens : list[str]</span>
<span class="sd">            The list of input tokens to process through the FST.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Generator[FstOutput]</span>
<span class="sd">            A generator of matches found during the traversal with their corresponding weights.</span>

<span class="sd">        Note</span>
<span class="sd">        -----</span>
<span class="sd">        This function walks through the FST, recursively finding matches that it builds up through the traversal.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">current_token</span> <span class="o">=</span> <span class="n">input_tokens</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">input_tokens</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">current_node</span><span class="o">.</span><span class="n">out_transitions</span><span class="p">:</span>

            <span class="c1"># If the current transition is an epsilon transition, then consume no input and recurse.</span>
            <span class="k">if</span> <span class="n">edge</span><span class="o">.</span><span class="n">input_symbol</span> <span class="o">==</span> <span class="n">EPSILON</span><span class="p">:</span>

                <span class="c1"># Case: there are no more input tokens, but you have an epsilon transition to follow.</span>
                <span class="c1"># In this case, you follow the epsilon, and see if you&#39;re in an accepting state. If so,</span>
                <span class="c1"># then add the output of this transition to the matches and continue to the recursive step,</span>
                <span class="c1"># since there could be further epsilon transitions to follow.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">current_token</span> <span class="ow">and</span> <span class="n">edge</span><span class="o">.</span><span class="n">target_node</span><span class="o">.</span><span class="n">is_accepting_state</span> <span class="ow">and</span> <span class="n">edge</span><span class="o">.</span><span class="n">output_symbol</span><span class="p">:</span>
                    <span class="n">path_weight</span> <span class="o">=</span> <span class="kc">None</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_semiring</span><span class="p">:</span>
                        <span class="n">path_weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_semiring</span><span class="o">.</span><span class="n">get_path_weight</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">target_node</span><span class="o">.</span><span class="n">final_state_weight</span><span class="p">)</span>

                    <span class="k">yield</span> <span class="n">FstOutput</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">output_symbol</span><span class="p">,</span> <span class="n">path_weight</span><span class="p">)</span>

                <span class="n">recursive_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__traverse_down</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">target_node</span><span class="p">,</span> <span class="n">input_tokens</span><span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">recursive_results</span><span class="p">:</span>
                        <span class="n">output_string</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">output_symbol</span> <span class="o">+</span> <span class="n">result</span><span class="o">.</span><span class="n">output_string</span>
                        <span class="n">path_weight</span> <span class="o">=</span> <span class="kc">None</span>

                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_semiring</span><span class="p">:</span>
                            <span class="n">path_weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_semiring</span><span class="o">.</span><span class="n">get_path_weight</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">path_weight</span><span class="p">)</span>
                        
                        <span class="k">yield</span> <span class="n">FstOutput</span><span class="p">(</span><span class="n">output_string</span><span class="p">,</span> <span class="n">path_weight</span><span class="p">)</span>

                <span class="k">except</span> <span class="ne">RecursionError</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="c1"># If we have found an explicit match of the current token with the edge&#39;s input token, then we are going</span>
            <span class="c1"># to want to create the new input symbols for the next level of recursion by chopping off the current token,</span>
            <span class="c1"># and getting the resulting output of that recursion. Then, we&#39;ll want to loop over that result, and, since</span>
            <span class="c1"># we consumed an input token over this current transition, we add ``edge.output_symbol + result`` to the matches.</span>
            <span class="k">elif</span> <span class="n">current_token</span> <span class="o">==</span> <span class="n">edge</span><span class="o">.</span><span class="n">input_symbol</span><span class="p">:</span>
                
                <span class="n">new_input_tokens</span> <span class="o">=</span> <span class="n">input_tokens</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">new_input_tokens</span> <span class="ow">and</span> <span class="n">edge</span><span class="o">.</span><span class="n">target_node</span><span class="o">.</span><span class="n">is_accepting_state</span><span class="p">:</span>
                    <span class="n">path_weight</span> <span class="o">=</span> <span class="kc">None</span>

                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_semiring</span><span class="p">:</span>
                        <span class="n">path_weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_semiring</span><span class="o">.</span><span class="n">get_path_weight</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="n">edge</span><span class="o">.</span><span class="n">target_node</span><span class="o">.</span><span class="n">final_state_weight</span><span class="p">)</span>

                    <span class="k">yield</span> <span class="n">FstOutput</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">output_symbol</span><span class="p">,</span> <span class="n">path_weight</span><span class="p">)</span>

                <span class="n">recursive_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__traverse_down</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">target_node</span><span class="p">,</span> <span class="n">new_input_tokens</span><span class="p">)</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">recursive_results</span><span class="p">:</span>
                        <span class="n">output_string</span> <span class="o">=</span> <span class="n">edge</span><span class="o">.</span><span class="n">output_symbol</span> <span class="o">+</span> <span class="n">result</span><span class="o">.</span><span class="n">output_string</span>
                        <span class="n">path_weight</span> <span class="o">=</span> <span class="kc">None</span>

                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_semiring</span><span class="p">:</span>
                            <span class="n">path_weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_semiring</span><span class="o">.</span><span class="n">get_path_weight</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">path_weight</span><span class="p">)</span>
                        
                        <span class="k">yield</span> <span class="n">FstOutput</span><span class="p">(</span><span class="n">output_string</span><span class="p">,</span> <span class="n">path_weight</span><span class="p">)</span>

                <span class="k">except</span> <span class="ne">RecursionError</span><span class="p">:</span>
                    <span class="k">pass</span>

    <span class="c1">#endregion</span>


    <span class="c1">#region Up/Analysis Methods</span>

<div class="viewcode-block" id="Fst.up_analyses">
<a class="viewcode-back" href="../../source/fst_runtime.html#fst_runtime.fst.Fst.up_analyses">[docs]</a>
    <span class="k">def</span> <span class="nf">up_analyses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wordforms</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Generator</span><span class="p">[</span><span class="n">FstOutput</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calls ``up_analysis`` for each wordform and returns a dictionary keyed on each wordform.</span>

<span class="sd">        The values in the dictionary are generators of tagged forms returned by the FST.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        wordforms : list[str]</span>
<span class="sd">            The list of wordforms to process.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        dict[str, Generator[FstOutput]]</span>
<span class="sd">            A dictionary where each key is a wordform and the value is a generator of tagged forms generated by the FST, along with their weights.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        up_analysis : For more information on how each wordform is processed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tagged_forms</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">wordform</span> <span class="ow">in</span> <span class="n">wordforms</span><span class="p">:</span>
            <span class="n">tagged_forms</span><span class="p">[</span><span class="n">wordform</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">up_analysis</span><span class="p">(</span><span class="n">wordform</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tagged_forms</span></div>

    

<div class="viewcode-block" id="Fst.up_analysis">
<a class="viewcode-back" href="../../source/fst_runtime.html#fst_runtime.fst.Fst.up_analysis">[docs]</a>
    <span class="k">def</span> <span class="nf">up_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wordform</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">FstOutput</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queries the FST up, or in the direction of analysis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        wordform : str</span>
<span class="sd">            The wordform to process.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Generator[FstOutput]</span>
<span class="sd">            A generator of tagged forms that could lead to the provided wordform, along with their weights.</span>

<span class="sd">        Note</span>
<span class="sd">        -----</span>
<span class="sd">        This function queries the FST in the direction of analysis by starting at the accepting states. Instead of looking at </span>
<span class="sd">        the input symbols for a node and the out transitions, it looks at the output symbols of the node and the in transitions. </span>
<span class="sd">        In this way, the FST becomes reversed. For example, ``walking -&gt; wal+GER``. There can be several tagged forms that lead to </span>
<span class="sd">        a single word. For instance, the word ``walk`` can have forms like ``wal+VERB+1Sg+Pres``, ``wal+VERB+2Sg+Pres``, etc., that lead </span>
<span class="sd">        to its generation. All these tagged forms are aggregated and returned.</span>

<span class="sd">        This method starts at the accepting states and looks at the output symbols of the node and the in transitions,</span>
<span class="sd">        effectively reversing the FST. While down/generation generates forms from a lemma plus some tags, the up/analysis </span>
<span class="sd">        direction takes a word form and generates the tagged forms that could lead to that particular word form.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">original_recursion_limit</span> <span class="o">=</span> <span class="mi">0</span>
        
        <span class="c1"># If the recursion limit has been set, the save the original value, and set it to the specified one.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">recursion_limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">original_recursion_limit</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">getrecursionlimit</span><span class="p">()</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">setrecursionlimit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">recursion_limit</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">accepting_state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_accepting_states</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">recursive_results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traverse_up</span><span class="p">(</span><span class="n">accepting_state</span><span class="p">,</span> <span class="n">wordform</span><span class="p">)</span>

            <span class="c1"># This reverses the final output as the string being returned from the recursion is backwards since we&#39;re going in the up direction.</span>
            <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">recursive_results</span><span class="p">:</span>
                <span class="n">finalized_output_string</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">output_string</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">EPSILON</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">dataclass_replace</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">output_string</span><span class="o">=</span><span class="n">finalized_output_string</span><span class="p">,</span> <span class="n">input_string</span><span class="o">=</span><span class="n">wordform</span><span class="p">)</span>

        <span class="c1"># Reset recursion limit before exiting the function.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">recursion_limit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">setrecursionlimit</span><span class="p">(</span><span class="n">original_recursion_limit</span><span class="p">)</span></div>

        

    <span class="k">def</span> <span class="nf">_traverse_up</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_state</span><span class="p">:</span> <span class="n">_FstNode</span><span class="p">,</span> <span class="n">wordform</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">FstOutput</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Handles the recursive walk through the FST.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        current_state : _FstNode</span>
<span class="sd">            The current state node to start the traversal from.</span>
<span class="sd">            </span>
<span class="sd">        wordform : str</span>
<span class="sd">            The wordform to be processed during the traversal.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Generator[FstOutput]</span>
<span class="sd">            A generator of symbols outputted from the FST during the walk, along with their weights.</span>

<span class="sd">        Note</span>
<span class="sd">        -----</span>
<span class="sd">        This function recursively walks through the FST starting from the given state node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">current_char</span> <span class="o">=</span> <span class="n">wordform</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">wordform</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">current_state</span><span class="o">.</span><span class="n">in_transitions</span><span class="p">:</span>

            <span class="k">def</span> <span class="nf">yield_results</span><span class="p">(</span><span class="n">new_wordform</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">current_edge</span><span class="p">:</span> <span class="n">_FstEdge</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">FstOutput</span><span class="p">]:</span>
                
                <span class="n">recursive_results</span><span class="p">:</span> <span class="n">Generator</span><span class="p">[</span><span class="n">FstOutput</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_traverse_up</span><span class="p">(</span><span class="n">current_edge</span><span class="o">.</span><span class="n">source_node</span><span class="p">,</span> <span class="n">new_wordform</span><span class="p">)</span>
            
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">result</span> <span class="ow">in</span> <span class="n">recursive_results</span><span class="p">:</span>
                        <span class="n">output_string</span> <span class="o">=</span> <span class="n">current_edge</span><span class="o">.</span><span class="n">input_symbol</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">result</span><span class="o">.</span><span class="n">output_string</span>
                        <span class="n">path_weight</span> <span class="o">=</span> <span class="kc">None</span>

                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_semiring</span><span class="p">:</span>
                            <span class="n">path_weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_semiring</span><span class="o">.</span><span class="n">get_path_weight</span><span class="p">(</span><span class="n">current_edge</span><span class="o">.</span><span class="n">weight</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">path_weight</span><span class="p">)</span>

                        <span class="k">yield</span> <span class="n">FstOutput</span><span class="p">(</span><span class="n">output_string</span><span class="p">,</span> <span class="n">path_weight</span><span class="p">)</span>

                <span class="k">except</span> <span class="ne">RecursionError</span><span class="p">:</span>
                    <span class="k">pass</span>

            <span class="c1"># If the current character matches the output symbol and takes you to the starting state, i.e. the end of the walk.</span>
            <span class="k">if</span> <span class="n">current_char</span> <span class="o">==</span> <span class="n">edge</span><span class="o">.</span><span class="n">output_symbol</span> <span class="ow">and</span> <span class="n">edge</span><span class="o">.</span><span class="n">source_node</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">Fst</span><span class="o">.</span><span class="n">_STARTING_STATE</span><span class="p">:</span>

                <span class="n">new_wordform</span> <span class="o">=</span> <span class="n">wordform</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># Since we&#39;re at the starting state, we check if there are any input characters left. If not, then we are at our base case.</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">new_wordform</span><span class="p">:</span>
                    <span class="c1"># This reverses the symbol since we&#39;re going up instead of down.</span>
                    <span class="k">yield</span> <span class="n">FstOutput</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">input_symbol</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">edge</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>

                <span class="k">yield from</span> <span class="n">yield_results</span><span class="p">(</span><span class="n">new_wordform</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span>

            <span class="c1"># Otherwise, output symbol is epsilon, then consume no characters.</span>
            <span class="k">elif</span> <span class="n">edge</span><span class="o">.</span><span class="n">output_symbol</span> <span class="o">==</span> <span class="n">EPSILON</span><span class="p">:</span>
                <span class="k">yield from</span> <span class="n">yield_results</span><span class="p">(</span><span class="n">wordform</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span>

            <span class="c1"># Otherwise, current character matches output character, so chop off the current character..</span>
            <span class="k">elif</span> <span class="n">current_char</span> <span class="o">==</span> <span class="n">edge</span><span class="o">.</span><span class="n">output_symbol</span><span class="p">:</span>
                <span class="k">yield from</span> <span class="n">yield_results</span><span class="p">(</span><span class="n">wordform</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">edge</span><span class="p">)</span></div>


    <span class="c1">#endregion</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, CultureFoundry Inc.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>